# üìë Documenta√ß√£o de Refatora√ß√£o ‚Äî Linketinder

## Objetivo

Refatorar o projeto **Linketinder** aplicando **Padr√µes de Projeto** para melhorar:
- Organiza√ß√£o
- Manuten√ß√£o
- Evolu√ß√£o futura
- Legibilidade para novos desenvolvedores.

---

## üî• Padr√µes de Projeto Aplicados

### 1. Factory Pattern

Cria√ß√£o de duas f√°bricas:
- `ControllerFactory`: Respons√°vel por instanciar Controllers.
- `ViewFactory`: Respons√°vel por instanciar Views, j√° configuradas com seus respectivos Controllers.
- `ConnectionFactory`: ConnectionFactory: Respons√°vel por fornecer conex√µes com o Banco de Dados, permitindo trocar o banco facilmente.

**Antes da Refatora√ß√£o**:
- A cria√ß√£o dos objetos (Repositories, Controllers e Views) era feita manualmente dentro da classe `AppConfig`.
- O `AppConfig` estava polu√≠do e dif√≠cil de dar manuten√ß√£o.
- A conex√£o com o Banco de Dados era r√≠gida e acoplada diretamente ao PostgreSQL.

**Depois da Refatora√ß√£o**:
- Toda a cria√ß√£o de objetos foi isolada nas f√°bricas, deixando o `AppConfig` limpo e organizado.
- A conex√£o com o Banco foi isolada, permitindo no futuro mudar facilmente o tipo de Banco de Dados.

**Exemplo de uso ap√≥s refatora√ß√£o**:
```groovy
this.candidatoView = ViewFactory.criarCandidatoView()
```
### 2. Singleton Pattern

- Garantir que exista apenas uma inst√¢ncia da conex√£o.
- Melhorar o controle de recursos do sistema.
- Evitar problemas de concorr√™ncia e m√∫ltiplas conex√µes abertas.

**Como foi implementado:**
- Criamos uma classe `ConnectionFactory` que gerencia a inst√¢ncia √∫nica da conex√£o.
- A inst√¢ncia da conex√£o √© criada apenas quando necess√°ria (lazy initialization).
- A inst√¢ncia √© reutilizada durante o ciclo de vida da aplica√ß√£o, evitando a cria√ß√£o de m√∫ltiplas conex√µes.

**Exemplo de c√≥digo da implementa√ß√£o**:

```groovy
    class ConnectionFactory {

    private static Connection connection

    static String url = "jdbc:postgresql://localhost:5432/Teste"
    static String user = "geek"
    static String password = "1234"

    private ConnectionFactory() {}

    static Connection getConnection() {
        if (connection == null || connection.isClosed()) {
            try {
                Class.forName("org.postgresql.Driver")
                connection = DriverManager.getConnection(url, user, password)
            } catch (ClassNotFoundException | SQLException e) {
                e.printStackTrace()
            }
        }
        return connection
    }
}
```

## ‚ú® Melhorias Obtidas

**üîπ Baixo Acoplamento**

- O `AppConfig` n√£o precisa mais saber como criar objetos ‚Äî s√≥ consome.
- Mudan√ßas em DAOs ou Controllers n√£o afetam quem os utiliza.

**üîπ Alta Coes√£o**

- Cada classe tem agora uma responsabilidade √∫nica:
    - Factories criam objetos.
    - Controllers controlam a l√≥gica de neg√≥cios.
    - Views se comunicam com o usu√°rio.

**üîπ Facilidade para Testes**

- Poss√≠vel usar inje√ß√£o de depend√™ncias facilmente.
- Permite substituir implementa√ß√µes por fakes ou mocks nos testes unit√°rios.

**üîπ C√≥digo Mais Limpo**

- `AppConfig` agora ficou com poucas linhas.
- O fluxo de instanciar o sistema ficou mais direto e compreens√≠vel.

**üîπ Flexibilidade e Escalabilidade**

- Se precisar adicionar novos Controllers ou Views, basta alterar as f√°bricas.
- Crescimento do sistema ser√° mais seguro e organizado.

## üìú Resumo das Altera√ß√µes

| Item                           | Antes da Refatora√ß√£o           | Depois da Refatora√ß√£o                                                |
|--------------------------------| ------------------------------ |----------------------------------------------------------------------|
| Instancia√ß√£o de objetos        | Manual, dentro do `AppConfig`  | Centralizada em `ControllerFactory` e `ViewFactory`                  |
| Cria√ß√£o de Controllers e Views | Direto no `AppConfig`          | Isolada nas Factories                                                |
| Padr√µes de Projeto             | Nenhum                         | Factory Pattern aplicado e Singleton planejado                       |
| Organiza√ß√£o do c√≥digo          | `AppConfig` extenso e confuso  | `AppConfig` enxuto, organizado e leg√≠vel                             |
| Facilidade de testes           | Dif√≠cil                        | Alta, com suporte a mocks                                            |
| Flexibilidade para altera√ß√µes  | Baixa                          | Alta, apenas Factories precisam ser alteradas                        |
| Instancia√ß√£o da Conex√£o	       | Criada em m√∫ltiplos locais | Inst√¢ncia √∫nica criada e gerenciada pelo Singleton                   |
| Gest√£o de Conex√µes             | M√∫ltiplas conex√µes abertas | Conex√£o √∫nica, reutilizada durante todo o ciclo de vida da aplica√ß√£o |
| Possibilidade de trocar Banco  | R√≠gido (PostgreSQL fixo) | Flex√≠vel, alterando apenas par√¢metros da ConnectionFactory           |


## ‚úÖ Conclus√£o

A aplica√ß√£o dos padr√µes Factory e Singleton no projeto Linketinder trouxe:

- Melhor organiza√ß√£o
- Melhor manuten√ß√£o
- Facilidade para testes
- Escalabilidade
